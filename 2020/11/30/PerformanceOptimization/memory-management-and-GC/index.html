<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Qiana">





<title>性能优化1--内存管理与垃圾回收机制 | Qiana前端小栈</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/jquery.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="/">Qiana&#39;s Blog</a>
            </div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文档</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                    <label for="switch_default" class="toggleBtn"></label>
                </div>
            </div>
        </nav>

        
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">Qiana&#39;s Blog</a>
                        <a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776;</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">文档</a>
                    
                        <a class="menu-item" href="/category">分类</a>
                    
                        <a class="menu-item" href="/tag">标签</a>
                    
                        <a class="menu-item" href="/about">关于</a>
                    
                </div>
            </div>
        </nav>

    </header>
    <script>
        var mobileBtn = function f() {
            var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
            var mobileMenu = document.getElementById("mobile-menu");
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }
    </script>

        <div class="main">
            <div
    class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">性能优化1--内存管理与垃圾回收机制</h1>
            
                <div class="post-meta">
                    
                        作者:
                        <a itemprop="author" rel="author" href="/">Qiana</a>&nbsp;&nbsp;
                    

                    
                        <span class="post-time">
                            日期:
                            <a href="#">2020-11-30</a>&nbsp;&nbsp;
                        </span>
                    
                    
                        <span class="post-category">
                            分类:
                            
                                <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>&nbsp;&nbsp;
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>性能优化是不可避免的。所有的程序，都需要在性能上进行优化，或运行速度，或运行空间。</p>
<p>任何一种提高运行效率，降低运行开销的行为，都可以看作是一种优化操作。</p>
<h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ol>
<li>内存管理</li>
<li>垃圾回收与常用GC算法</li>
<li>V8引擎的垃圾回收</li>
<li>Performance工具</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存为什么需要管理"><a href="#内存为什么需要管理" class="headerlink" title="内存为什么需要管理"></a>内存为什么需要管理</h2><p>为了避免内存泄漏。</p>
<h2 id="什么是内存管理"><a href="#什么是内存管理" class="headerlink" title="什么是内存管理"></a>什么是内存管理</h2><p>内存： 由可读写单元组成，表示一片可操作空间。</p>
<p>管理：人为的去操作一片空间的申请、使用、释放。</p>
<p>内存管理：开发者主动申请空间、使用空间、释放空间。</p>
<p>管理流程：申请-使用-释放</p>
<h2 id="JS中的内存管理"><a href="#JS中的内存管理" class="headerlink" title="JS中的内存管理"></a>JS中的内存管理</h2><blockquote>
<p>JS中的内存管理是自动的。</p>
</blockquote>
<p>申请内存空间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用内存空间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.name = <span class="string">&quot;this is name&quot;</span></span><br></pre></td></tr></table></figure>

<p>释放内存空间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><ol>
<li>内存泄露：内存使用持续升高</li>
<li>内存膨胀（内存溢出）：在多数设备上都存在性能问题</li>
<li>频繁垃圾回收：通过内存变化图可以进行分析</li>
</ol>
<h2 id="内存出现问题的外在表现"><a href="#内存出现问题的外在表现" class="headerlink" title="内存出现问题的外在表现"></a>内存出现问题的外在表现</h2><ol>
<li>页面出现延迟加载或经常性暂停 — 频繁的垃圾回收</li>
<li>页面持续性出现糟糕的性能 — 内存膨胀</li>
<li>页面的性能随着时间延长越来越差 — 内存泄漏</li>
</ol>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="jS中的垃圾"><a href="#jS中的垃圾" class="headerlink" title="jS中的垃圾"></a>jS中的垃圾</h2><ol>
<li>对象不再被引用时是垃圾</li>
<li>对象不能从根上访问到时是垃圾</li>
</ol>
<h2 id="可达对象"><a href="#可达对象" class="headerlink" title="可达对象"></a>可达对象</h2><blockquote>
<p> 从根出发，可以访问到的对象即为可达对象。</p>
</blockquote>
<p>在JS中，根可以理解为全局变量对象。</p>
<p>从根出发，通过引用或作用域链能访问到的对象都是可达对象。</p>
<h2 id="垃圾回收算法（GC算法）"><a href="#垃圾回收算法（GC算法）" class="headerlink" title="垃圾回收算法（GC算法）"></a>垃圾回收算法（GC算法）</h2><blockquote>
<p>GC即垃圾回收机制的简写</p>
</blockquote>
<p>GC工作的时候，会找到内存中的垃圾并释放和回收空间。</p>
<p><strong>GC中的垃圾</strong>：</p>
<ol>
<li>程序中不再需要使用的对象</li>
<li>程序中不能再访问到的对象</li>
</ol>
<p><strong>什么是GC算法</strong>：</p>
<ul>
<li>GC是一种机制，垃圾回收器完成具体的查找垃圾、释放空间、回收空间的工作。</li>
<li>算法是查找垃圾、释放空间、回收空间所遵循的规则。</li>
</ul>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>内部通过一个引用计数器来维护当前对象的引用数。通过判断当前引用数值是否为0，来判断该对象是否为一个垃圾对象。若该对象的引用数为0，则GC开始工作，对其所在的对象空间进行回收和再使用。</p>
<p>当引用关系发生改变的时候，引用计数器就会修改引用数字。</p>
<p>当引用数字为0的时候，立即回收。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ol>
<li>发现垃圾时回立即回收</li>
<li>减少程序卡顿时间</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>无法回收循环引用的对象</li>
<li>维护引用计数器需要额外的空间及时间开销</li>
</ol>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>核心思想：将垃圾回收分为标记和清除两个阶段。</p>
<p>​    标记阶段，遍历所有对象，标记活动对象（可达对象）。</p>
<p>​    清除阶段，遍历所有对象，将没有标记的对象进行清除。同时，将第一个阶段的标记抹掉，方便下次进行标记清除工作。最后，回收相应空间。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ol>
<li>可以回收循环引用的对象</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>会产生空间碎片化，浪费空间</li>
<li>不会立即回收垃圾对象</li>
<li>回收垃圾对象的时候，程序需要暂停执行</li>
</ol>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><blockquote>
<p>标记清除的一个增强工作</p>
</blockquote>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>标记阶段： 与标记清除的标记阶段完全一致，遍历所有对象，标记所有活动对象（可达对象）</p>
<p>清除阶段：先执行整理，移动对象位置，是活动对象在地址上连续</p>
<p>​                    然后执行清除工作，遍历所有对象，将没有标记的对象清除，回收相应的空间。</p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<ol>
<li>可以回收循环引用的对象</li>
<li>减少碎片化空间</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>不会立即回收垃圾对象</li>
</ol>
<h3 id="标记增量"><a href="#标记增量" class="headerlink" title="标记增量"></a>标记增量</h3><blockquote>
<p>V8老生代存储空间使用标记增量算法提升效率</p>
</blockquote>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>在标记阶段，采用分阶段标记，将程序运行与垃圾回收交替进行。不会长时间阻断程序运行。</p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p>
<p>​    不会长时间阻断程序运行，提升程序运行效率，有利于用户体验。</p>
<p><strong>缺点</strong></p>
<p>​    不会立即回收垃圾对象</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><blockquote>
<p>V8引擎采用了分代回收算法</p>
</blockquote>
<h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>将内存空间分为新生代对象存储空间和老生代对象存储空间。</p>
<p>针对不同的存储空间，使用不同的垃圾回收机制。</p>
<h3 id="空间复制"><a href="#空间复制" class="headerlink" title="空间复制"></a>空间复制</h3><blockquote>
<p>V8新生代存储空间采用了空间复制的垃圾回收算法。</p>
</blockquote>
<h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>将存储空间分为两个区域，一个区域用于存放对象，称为From空间，一个区域空闲，称为To空间。</p>
<p>将From空间的活动对象复制到To空间，将From空间完全释放回收。再将From空间与To空间进行交换。</p>
<h4 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h4><p>回收速度快，是一种用空间换时间的算法</p>
<h1 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h1><blockquote>
<p>一款主流的JavaScript执行引擎</p>
</blockquote>
<p>V8采用即时编译，可以将源码直接翻译成可以直接执行的机器码，所以其执行速度很快。</p>
<p>V8内存设有上限，在64位的操作系统上，上限为1.5G，在32位操作系统上，上限为800M。</p>
<p><em>为什么对内存设有上限？</em></p>
<pre><code>    1. V8本身是为浏览器制造的，现有内存大小对于网页应用来数是足够的。
      2. V8内部采用的垃圾回收机制也决定了V8采用的这个上限设置是合理的。</code></pre>
<h2 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h2><blockquote>
<p>采用分代回收的思路。</p>
</blockquote>
<p>将内存分为新生代对象存储空间和老生代对象存储空间，针对不同的对象采用不同算法。</p>
<p>V8将内存空间分为两部分，</p>
<p>其中较小的空间用于存储新生代对象，其空间大小有限制：在64位操作系统中，其大小为32M，在32位操作系统中，其大小为16M。</p>
<p>其中较大的空间用于存储老生代对象，其空间大小也有限制：在64为操作系统中，其大小为1.4G，在32为操作系统中，其大小为700M。</p>
<p><strong>新生代对象</strong>：存活时间较短的对象。</p>
<p><strong>老生代对象</strong>：存活时间较长的对象。</p>
<h3 id="V8-新生代对象回收"><a href="#V8-新生代对象回收" class="headerlink" title="V8 新生代对象回收"></a>V8 新生代对象回收</h3><blockquote>
<p>回收过程采用 <strong>复制算法</strong> + <strong>标记整理算法</strong></p>
</blockquote>
<p>新生代内存区分为两个等大小的空间，其中一个空间用于存放活动对象，称其为From空间，另一个空间空闲，称其为To空间。</p>
<p>对Form空间进行标记整理后，将活动对象拷贝至To空间，将From空间进行完全释放。将From空间与To空间进行交换。</p>
<p><strong>拷贝过程中可能会出现晋升</strong>：将新生代对象移至老生代空间</p>
<p>​    会发生晋升的对象为：1. 记过一轮GC之后还存活的对象，  2. To空间的使用率超过了25%时，To空间中的活动对象</p>
<h3 id="V8老生代对象回收"><a href="#V8老生代对象回收" class="headerlink" title="V8老生代对象回收"></a>V8老生代对象回收</h3><blockquote>
<p>回收过程采用 <strong>标记清除算法</strong> + <strong>标记整理算法</strong> + <strong>标记增量算法</strong></p>
</blockquote>
<p>首先，使用<strong>标记清除算法</strong>完成垃圾空间的回收。</p>
<p>当新生代对象晋升到老生代空间，而老生代空间存储区不足以存放晋升对象时，采用<strong>标记整理</strong>进行空间优化。</p>
<p>采用标记增量算法进行效率优化。</p>
<p><strong>标记增量算法</strong></p>
<p>将标记操作拆分成多个小步，组合着完成这个回收。</p>
<p>将垃圾回收与程序执行交替工作，优化程序运行，提升用户体验。</p>
<h1 id="Performance工具"><a href="#Performance工具" class="headerlink" title="Performance工具"></a>Performance工具</h1><blockquote>
<p>通过Proformance可以时刻监控内存</p>
</blockquote>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>打开浏览器，输入目标地址</li>
<li>进入开发者工具面板，选择性能</li>
<li>开启录制功能，访问具体页面</li>
<li>执行用户行为，一段时间后停止录制</li>
<li>分析界面中记录的内存信息</li>
</ol>
<h2 id="使用堆快照功能查找分离DOM"><a href="#使用堆快照功能查找分离DOM" class="headerlink" title="使用堆快照功能查找分离DOM"></a>使用堆快照功能查找分离DOM</h2><h3 id="什么是分离DOM"><a href="#什么是分离DOM" class="headerlink" title="什么是分离DOM"></a>什么是分离DOM</h3><p>正常情况下，界面元素存活在DOM树上。</p>
<p>当元素从DOM树上进行了脱离，并且JS代码中也没有对该DOM元素的引用，则该DOM节点为一个垃圾对象。</p>
<p>当元素从DOM树上脱离了，但是JS代码中还有对该DOM元素的引用，则，该DOM节点为分离DOM。</p>
<p>分离DOM在界面上看不到，但是会占用内存空间，是一种内存泄漏。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
        </div>

        
        <section class="post-tags">
            <div>
                <span>
                    标签:</span>
                <span class="tag">
                    
                        
                            <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">#
                                性能优化</a>
                        
                            <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">#
                                内存管理</a>
                        
                            <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">#
                                垃圾回收</a>
                        
                            <a href="/tags/V8%E5%BC%95%E6%93%8E/">#
                                V8引擎</a>
                        
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">后退
                </a>
                <span>·
                </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/12/01/PerformanceOptimization/code-optimization/">性能优化2-代码层面优化</a>
            
            
                <a class="next" rel="next" href="/2020/11/27/TS/TypeScript/">TypeScript</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Qiana | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
