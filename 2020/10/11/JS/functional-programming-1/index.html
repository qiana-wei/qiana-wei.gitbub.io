<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Qiana">





<title>函数式编程 | Qiana前端小栈</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/jquery.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="/">Qiana&#39;s Blog</a>
            </div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文档</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                    <label for="switch_default" class="toggleBtn"></label>
                </div>
            </div>
        </nav>

        
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="/">Qiana&#39;s Blog</a>
                        <a id="mobile-toggle-theme">·&nbsp;Light</a>
                    </div>
                    <div class="menu-toggle" onclick="mobileBtn()">&#9776;</div>
                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/archives">文档</a>
                    
                        <a class="menu-item" href="/category">分类</a>
                    
                        <a class="menu-item" href="/tag">标签</a>
                    
                        <a class="menu-item" href="/about">关于</a>
                    
                </div>
            </div>
        </nav>

    </header>
    <script>
        var mobileBtn = function f() {
            var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
            var mobileMenu = document.getElementById("mobile-menu");
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }
    </script>

        <div class="main">
            <div
    class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">函数式编程</h1>
            
                <div class="post-meta">
                    
                        作者:
                        <a itemprop="author" rel="author" href="/">Qiana</a>&nbsp;&nbsp;
                    

                    
                        <span class="post-time">
                            日期:
                            <a href="#">2020-10-11</a>&nbsp;&nbsp;
                        </span>
                    
                    
                        <span class="post-category">
                            分类:
                            
                                <a href="/categories/JS/">JS</a>&nbsp;&nbsp;
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><blockquote>
<p>函数式编程（Function Programming, 缩写：FP）。是一种<a href="/2020/10/11/JS/programming-parading/">编程范式</a>。</p>
</blockquote>
<p>函数式编程将计算机运算视为函数运算，并且避免使用程序状态以及易变对象。</p>
<p>λ演算(lambda calculus)是函数式编程最重要的基础。</p>
<p>λ演算的函数可以接受函数作为输入和输出。</p>
<h1 id="为什么学习函数式编程"><a href="#为什么学习函数式编程" class="headerlink" title="为什么学习函数式编程"></a>为什么学习函数式编程</h1><p><strong>1.外部环境需要</strong></p>
<ul>
<li>函数式编程是随着React的流行收到越来越多的关注。<ul>
<li>React中的高阶组件是由高阶函数来实现的。高阶函数是函数式编程的一个特性。</li>
<li>React的原生生态Redux使用了函数式编程的思想</li>
</ul>
</li>
<li>Vue3也开始拥抱函数式编程<ul>
<li>Vue3的composition Api越来越偏向函数式</li>
<li>Vue2的源码中也大量使用了高阶函数</li>
</ul>
</li>
</ul>
<p><strong>2.函数式编程本事益处</strong></p>
<ul>
<li>得益于函数式编程变量的不可变性，函数引用透明，没有副作用。</li>
<li>由于函数式编程没有副作用，不影响外部环境，不依赖外部环境，使得函数式编程的程序不易出错，易于单元测试和调试</li>
<li>函数式编程无this指向问题</li>
<li>函数式编程多个线程不共享状态，不争夺资源，不需要锁保护可变状态，不会出现锁死现象。所以能够够好的处理并发问题。</li>
<li>在函数式编程中，将表达式赋值给变量时，不做计算，当变量第一次被使用时才会做计算，通过惰性求值，提高性能。</li>
</ul>
<p><strong>3.外部环境支持</strong></p>
<ul>
<li>打包过程中可以更好的使用 tree shaking过滤无用代码</li>
<li>lodash, underscore,ramda等库可以帮助我们进行函数式开发</li>
</ul>
<h1 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h1><h2 id="1-函数是一等公民"><a href="#1-函数是一等公民" class="headerlink" title="1.函数是一等公民"></a>1.函数是一等公民</h2><blockquote>
<p>在函数式编程中，函数可以在任何地方定义、使用。</p>
</blockquote>
<p>函数可以存储在变量中，可以作为参数，可以作为返回值。</p>
<p><strong>把函数赋值给变量</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把函数赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello First-class Function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h2 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2.高阶函数"></a>2.高阶函数</h2><blockquote>
<p>可以把函数作为参数传递给另外一个函数。</p>
<p>函数可以作为另外一个函数的返回值</p>
</blockquote>
<h3 id="高阶函数–函数作为参数"><a href="#高阶函数–函数作为参数" class="headerlink" title="高阶函数–函数作为参数"></a>高阶函数–函数作为参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟forEach</span></span><br><span class="line"><span class="keyword">let</span> forEach = <span class="function"><span class="keyword">function</span>(<span class="params">array,fn</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">      fn(array[i])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">forEach(arr,<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟filter</span></span><br><span class="line"><span class="keyword">let</span> filter= <span class="function"><span class="keyword">function</span>(<span class="params">array,fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fn(array[i]))&#123;</span><br><span class="line">      arr.push(array[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> newArray = filter(arr,<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArray)</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数—函数作为返回值"><a href="#高阶函数—函数作为返回值" class="headerlink" title="高阶函数—函数作为返回值"></a>高阶函数—函数作为返回值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟once函数</span></span><br><span class="line"><span class="keyword">const</span> once =  <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isDone = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isDone)&#123;</span><br><span class="line">      isDone = <span class="literal">true</span>;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> pay = once(<span class="function"><span class="keyword">function</span>(<span class="params">money</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(money)</span><br><span class="line">&#125;)</span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的意义"><a href="#高阶函数的意义" class="headerlink" title="高阶函数的意义"></a>高阶函数的意义</h3><p>抽象可以帮我们屏蔽实现的细节，只需要关注我们的目标。</p>
<p>高阶函数用来抽象通用问题。</p>
<p>将复用的粒度降低到函数级别，使函数变得灵活。</p>
<h3 id="常用高阶函数"><a href="#常用高阶函数" class="headerlink" title="常用高阶函数"></a>常用高阶函数</h3><p>模拟map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="keyword">function</span>(<span class="params">array,fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> array)&#123;</span><br><span class="line">    result.push(fn(value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> result = map(array,<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item*item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//箭头函数不加花括号时，有默认返回值</span></span><br><span class="line"><span class="comment">//let result = map(array,item=&gt;item*item)</span></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">//[1,9,16,36,25]</span></span><br></pre></td></tr></table></figure>

<h2 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h2><p> 函数中引用了<strong>自由变量</strong>，便形成了闭包。</p>
<p>自由变量：不属于当前函数作用域的变量。</p>
<p><strong>闭包的本质</strong>：</p>
<p>函数在执行的时候会放到一个执行栈上，当函数执行完毕后，会从执行栈上移除。</p>
<p><strong>但是堆上的作用域成员因为被外部引用，不能释放</strong>，因此内部函数依然能够访问外部函数的成员。</p>
<p>闭包延长了外部函数内部变量的作用范围。</p>
<h2 id="4-不可变性（纯函数）"><a href="#4-不可变性（纯函数）" class="headerlink" title="4.不可变性（纯函数）"></a>4.不可变性（纯函数）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>函数式编程不保留计算的中间结果，所哟变量是无状态的，不可变的。</p>
<p>纯函数：相同的输入始终会得到相同的输出，而且没有任何可观察的副作用。</p>
<p>纯函数类似于数学中的函数，用来描述输入与输出之间的映射关系。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>slice返回数组中的指定部分，不修改原数组——-slice函数是纯函数</p>
<p>splice对数组进行操作，返回该数组，会改变原数组—–splice函数不是纯函数</p>
<h3 id="纯函数的好处"><a href="#纯函数的好处" class="headerlink" title="纯函数的好处"></a>纯函数的好处</h3><ol>
<li><p>可缓存</p>
<p>因为纯函数对相同的输入始终有相同的输出，所以可以把纯函数的结果缓存起来。</p>
<p><strong>Lodash memoize函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;loadsh&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAreas = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;半径：&#x27;</span>,r)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getAreasWithMemory() = _.memoize(getAreas)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getAreasWithMemory(<span class="number">4</span>)) <span class="comment">// 半径：4   50.26548245743669</span></span><br><span class="line"><span class="built_in">console</span>.log(getAreasWithMemory(<span class="number">4</span>)) <span class="comment">// 50.26548245743669</span></span><br><span class="line"><span class="built_in">console</span>.log(getAreasWithMemory(<span class="number">4</span>)) <span class="comment">// 50.26548245743669</span></span><br><span class="line"><span class="built_in">console</span>.log(getAreasWithMemory(<span class="number">5</span>)) <span class="comment">// 半径：5   78.53981633974483</span></span><br><span class="line"><span class="built_in">console</span>.log(getAreasWithMemory(<span class="number">4</span>)) <span class="comment">// 50.26548245743669</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//getAreasWithMemory函数在有相同输入的时候，getAreas仅执行一次，后续结果在缓存中读取</span></span><br></pre></td></tr></table></figure>

<p><strong>模拟memoize函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">    cache[key] = cache[key] ?? fn(...arguments)</span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可测试</p>
<p>纯函数始终有输入与输出，单元测试是断言函数的结果，所以，纯函数让测试更方便</p>
</li>
<li><p>并行处理</p>
<ul>
<li>在多线程环境下，并行操作存在共享数据时很可能会发生意外情况</li>
<li>纯函数是封闭空间，不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数</li>
</ul>
</li>
</ol>
<h2 id="5-副作用"><a href="#5-副作用" class="headerlink" title="5. 副作用"></a>5. 副作用</h2><p>由于函数依赖外部的状态，就无法保证函数会有相同的输出，就会带来副作用。</p>
<h3 id="副作用来源"><a href="#副作用来源" class="headerlink" title="副作用来源"></a>副作用来源</h3><ul>
<li>配置文件</li>
<li>数据库</li>
<li>获取用户的输入</li>
</ul>
<p>所有的外部交互都有可能带来副作用，副作用也使得方法的通用性下降，不利于拓展和可重用性。</p>
<p>同时，副作用会给程序带来安全隐患及不确定性。</p>
<p>但是副作用又不可能完全禁止，尽量控制它们在可控范围内发生。</p>
<h2 id="6-柯里化（Currying）"><a href="#6-柯里化（Currying）" class="headerlink" title="6.柯里化（Currying）"></a>6.柯里化（Currying）</h2><p><strong>将多个入参的函数，转化为需要更少入参的函数的方法</strong></p>
<p>柯里化是把<strong>接受 n 个参数的 1 个函数</strong>改造为<strong>只接受 1个参数的 n 个互相嵌套的函数</strong>的过程。</p>
<p>*<em>也就是 *fn(a,b,c)*会变成</em>fn(a)(b)(c)* **</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateName</span>(<span class="params">prefix, type, itemName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix + type + itemName</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateName</span>(<span class="params">prefix</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">itemName</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prefix + type + itemName</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯里化后调用</span></span><br><span class="line"><span class="keyword">var</span> itemFullName = generateName(<span class="string">&#x27;洗菜网&#x27;</span>)(<span class="string">&#x27;生鲜&#x27;</span>)(<span class="string">&#x27;菠菜&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>lodash中的柯里化函数</strong></p>
<p><strong>_.curry(fn)</strong></p>
<p>​    <strong>功能</strong>：创建一个函数，该函数接收一个或多个function参数。</p>
<p>如果function所需要的参数都被提供，则执行function并返回结果。</p>
<p>否则继续返回该函数并等待接收剩余的参数。</p>
<p>​    <strong>参数</strong>：需要柯里化的函数</p>
<p>​    <strong>返回值</strong>：柯里化后的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟lodash curry方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curriedFn</span> (<span class="params">...args</span>)</span>&#123;<span class="comment">// 给函数命名，方便递归调用</span></span><br><span class="line">    <span class="comment">// 判断实参 和 形参 个数是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(args.length &lt; fn.length)&#123;</span><br><span class="line">      <span class="comment">//不同，返回函数，等待后续参数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curriedFn(...[...args,...args2])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相同，执行函数</span></span><br><span class="line">    <span class="keyword">return</span> fn(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getSumWithCurry = curry(getSum)</span><br><span class="line"><span class="comment">// function curriedFn</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSumWithCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getSumWithCurry(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getSumWithCurry(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li>函数柯里化可以让我们给一个函数传递较少的参数，得到一个已经记住了某些固定参数的新函数</li>
<li>这是一种对参数的缓存</li>
<li>使得函数变得更灵活，让函数粒度更小</li>
<li>把多元函数转化为一元函数，可以组合使用函数产生强大的功能</li>
</ol>
<h2 id="7-偏函数"><a href="#7-偏函数" class="headerlink" title="7.偏函数"></a>7.偏函数</h2><p>与函数柯里化类似。</p>
<p>一个函数接收一个有多个参数的函数，返回一个需要较少参数的函数</p>
<p>偏函数将一个或多个参数固定到内部，返回一个需要较少参数的函数。</p>
<h1 id="函数组合（compose）"><a href="#函数组合（compose）" class="headerlink" title="函数组合（compose）"></a>函数组合（compose）</h1><p>使用纯函数和柯里化容易写出洋葱代码，函数组合可以让我们把细粒度的函数重新组合成一个新的函数。</p>
<p>如果一个函数要经过多个函数处理才能得到最终值，这个时候，可以把中间过程合并成一个函数。</p>
<p>函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果。</p>
<p><strong>函数组合默认是从右向左执行</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子，将f,g函数进行组合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f,g</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lodash中的组合函数"><a href="#lodash中的组合函数" class="headerlink" title="lodash中的组合函数"></a><strong>lodash</strong>中的组合函数</h3><p>lodash中flow()和flowRight()都可以组合多个函数。</p>
<p>flow()是从左到右运行。</p>
<p>flowRight()是从右到左执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lodash中使用flowRight函数，取数组最后一个值，并大写</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">array</span> =&gt;</span> array.reverse() <span class="comment">//反转函数</span></span><br><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">array</span> =&gt;</span> array[<span class="number">0</span>]	<span class="comment">//取最后一个值</span></span><br><span class="line"><span class="keyword">const</span> toUpper = <span class="function"><span class="params">str</span> =&gt;</span> str.toUpperCase() <span class="comment">//大写</span></span><br><span class="line"><span class="keyword">const</span> f = flowRight(toUpper,first,reverse)<span class="comment">//组合函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;case&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;Jack&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(f(array))  <span class="comment">//JACJK</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟flowRight</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flowRight</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reverse().reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc,cur</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cur(acc)</span><br><span class="line">    &#125;,value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数组合结合律"><a href="#函数组合结合律" class="headerlink" title="函数组合结合律"></a>函数组合结合律</h3><p>函数组合要满足结合律(associative)</p>
<p>a*b*c == a*(b*c) == (a*b)*c</p>
<p>即函数f,g,h组合时，f,g组合后再与h组合  与 g,h组合后再与f组合，结果是一样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = compose(f,g,h)</span><br><span class="line"><span class="keyword">let</span> associative = compose(compose(f,g),h)  === compose(f,compose(g,h))</span><br><span class="line"><span class="comment">//associactive == true</span></span><br></pre></td></tr></table></figure>

<h3 id="如何调试函数组合"><a href="#如何调试函数组合" class="headerlink" title="如何调试函数组合"></a>如何调试函数组合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> split = _.curry(<span class="function">(<span class="params">sep,str</span>)=&gt;</span>_.split(str,sep))</span><br><span class="line"><span class="keyword">const</span> join = _.curry(<span class="function">(<span class="params">sep,arr</span>)=&gt;</span>_.join(arr,sep))</span><br><span class="line"><span class="keyword">const</span> map = _.curry(<span class="function">(<span class="params">fn,array</span>)=&gt;</span>_.map(array,fn))</span><br><span class="line"><span class="comment">//调试函数</span></span><br><span class="line"><span class="keyword">const</span> log = _.curry(<span class="function">(<span class="params">tag,v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tag,v)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = _.flowRight(join(<span class="string">&#x27;-&#x27;</span>),log(<span class="string">&#x27;map后打印的&#x27;</span>),map(_.toLower),log(<span class="string">&#x27;split后打印的&#x27;</span>),split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">&#x27;NEVER SAY DIE&#x27;</span>))</span><br><span class="line"><span class="comment">// split后打印的 [ &#x27;NEVER&#x27;, &#x27;SAY&#x27;, &#x27;DIE&#x27; ]</span></span><br><span class="line"><span class="comment">// map后打印的 [ &#x27;never&#x27;, &#x27;say&#x27;, &#x27;die&#x27; ]</span></span><br><span class="line"><span class="comment">// never-say-die</span></span><br></pre></td></tr></table></figure>

<h1 id="Lodash-中的FP模块"><a href="#Lodash-中的FP模块" class="headerlink" title="Lodash 中的FP模块"></a>Lodash 中的FP模块</h1><p><a href="/2020/10/21/utility-library/Lodash/lodash-2/">点击看这里</a></p>
<h1 id="PointFree"><a href="#PointFree" class="headerlink" title="PointFree"></a>PointFree</h1><p>pointFree是一种编程风格，其具体实现是函数的组合</p>
<p>pointFree：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，值要把简单的步骤合成到一起。</p>
<p>在使用这种模式之前，我们需要定义一些辅助的基本运算函数。</p>
<p>即：</p>
<ul>
<li>不需要指明要处理的数据</li>
<li>只需要合成运算的过程</li>
<li>需要定义一些辅助的基本运算函数</li>
</ul>
<p>函数式编程即将运算过程抽象成函数，而PointFree即把我们抽象出来的函数，再组合成一个函数。</p>
<p><strong>案例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符串中首字母提取，并转换为大写，使用‘.’作为分隔符</span></span><br><span class="line"><span class="comment">//world wild web =&gt; W.W.W</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f = fp.flow(fp.split(<span class="string">&#x27; &#x27;</span>),fp.map(fp.flow(fp.first,fp.toUpper)),fp.join(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">&#x27;world wild web&#x27;</span>))</span><br><span class="line"><span class="comment">//W.W.W</span></span><br></pre></td></tr></table></figure>



<h1 id="函子（Funtor）"><a href="#函子（Funtor）" class="headerlink" title="函子（Funtor）"></a>函子（Funtor）</h1><h2 id="为什么要学函子"><a href="#为什么要学函子" class="headerlink" title="为什么要学函子"></a>为什么要学函子</h2><p>利用函子控制副作用，处理异常及异步操作。</p>
<h2 id="什么是函子（Funtor）"><a href="#什么是函子（Funtor）" class="headerlink" title="什么是函子（Funtor）"></a>什么是函子（Funtor）</h2><p>容器：包含值和值的变形关系（变形关系即为函数）</p>
<p>函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法。map方法可以接受一个参数，这个参数是对值进行处理的函数。</p>
<ul>
<li><p>函子维护一个值，值不对外公布</p>
</li>
<li><p>函子有map方法，对值进行处理，并返回一个包含新值的函子</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  map(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span> Container.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链式调用</span></span><br><span class="line"><span class="keyword">let</span> r = Container.of(<span class="number">5</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">x</span>=&gt;</span>x+<span class="number">2</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">x</span>=&gt;</span>x*x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure>

<h2 id="函子处理异常"><a href="#函子处理异常" class="headerlink" title="函子处理异常"></a>函子处理异常</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rseult = Container.of(<span class="literal">null</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">x</span>=&gt;</span>x.toUpperCase)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"><span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>当函子传入值为null时，函数因报错而没有输出。</p>
<h3 id="MayBe函子"><a href="#MayBe函子" class="headerlink" title="MayBe函子"></a>MayBe函子</h3><p>MayBe函子可以处理输入值为<strong>空值</strong>的异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayBe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MayBe(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  map(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">this</span>.isNothing() ? MayBe.of(<span class="literal">null</span>) : MayBe.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">  isNothing()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value === <span class="literal">null</span> || <span class="built_in">this</span>._value === <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = MayBe.of(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x.toUpperCase())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r2 = MayBe.of(<span class="literal">null</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x.toUpperCase())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r3 = MayBe.of(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x.toUpperCase())</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span><span class="literal">null</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"><span class="comment">//MayBe &#123; _value: &#x27;HELLO WORLD&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r2)</span><br><span class="line"><span class="comment">//MayBe &#123; _value: null &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r3)</span><br><span class="line"><span class="comment">//MayBe &#123; _value: null &#125;</span></span><br></pre></td></tr></table></figure>

<p>由上述例子可以看出，MayBe函子不会报错，但当异常发生时，不会报错，但也没有返回我们的预期。</p>
<p>MayBe函子虽然可以处理空值的问题，但是不知道是在哪一步发生了空值。</p>
<h3 id="Either函子"><a href="#Either函子" class="headerlink" title="Either函子"></a>Either函子</h3><p>Either函子会在函数出现异常时，给出异常的提示信息，用于异常处理。</p>
<p>拥有两个函子，当函数异常时，返回记录异常信息并其中一个函子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Left(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  map(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  map(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span> Right.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paseJson</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Right.of(<span class="built_in">JSON</span>.parse(str))</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">return</span> Left.of(&#123;<span class="attr">error</span>:e.message&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常</span></span><br><span class="line"><span class="keyword">let</span> r1 = paseJson(<span class="string">&#x27;&#123;name:zs&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r1)</span><br><span class="line"><span class="comment">//Left &#123; _value: &#123; error: &#x27;Unexpected token n in JSON at position 1&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正常</span></span><br><span class="line"><span class="keyword">let</span> r = paseJson(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;zs&quot;&#125;&#x27;</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">x</span>=&gt;</span>x.name.toUpperCase())</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"><span class="comment">//Right &#123; _value: &#x27;ZS&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h3><ul>
<li>IO函子中的_value是一个函数，是把函数作为值来处理的</li>
<li>IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作(惰性执行)，将有副作用的操作延迟到调用的时候</li>
<li>将有副作用的操作交给调用者来处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span></span>&#123;</span><br><span class="line">  <span class="comment">//返回值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将map中的函数与of中的函数组合成一个新的函数</span></span><br><span class="line">  map(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(fn,<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//process  node进程，execPath node执行位置</span></span><br><span class="line"><span class="keyword">let</span> r = IO.of(process).map(<span class="function"><span class="params">p</span>=&gt;</span>p.execPath)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将函数</span></span><br><span class="line"><span class="comment">function()&#123;</span></span><br><span class="line"><span class="comment">  return value</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">与函数</span></span><br><span class="line"><span class="comment">p=&gt;p.execPath</span></span><br><span class="line"><span class="comment">组合成一个函数组合</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回一个IO函子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"><span class="comment">//   IO &#123; _value: [Function (anonymous)] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(r._value())</span><br><span class="line"><span class="comment">//   /usr/local/Cellar/node/14.2.0/bin/node</span></span><br></pre></td></tr></table></figure>

<h2 id="函子处理异步"><a href="#函子处理异步" class="headerlink" title="函子处理异步"></a>函子处理异步</h2><p><a target="_blank" rel="noopener" href="https://folktale.origamitower.com/">Folktale</a>是一个标准的函数式编程库。没有提供很多功能函数，值提供了一些函数式处理的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//folktale中的curry 与 compose</span></span><br><span class="line"><span class="keyword">const</span> &#123; compose,curry&#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/core/lambda&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; toUpper,first &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = curry(<span class="number">2</span>,<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = compose(toUpper,first)</span><br><span class="line"><span class="built_in">console</span>.log(fn([<span class="string">&#x27;One&#x27;</span>,<span class="string">&#x27;Two&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="Tsak-函子处理异步"><a href="#Tsak-函子处理异步" class="headerlink" title="Tsak 函子处理异步"></a>Tsak 函子处理异步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	异步读取文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;task&#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/concurrency/task&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;split,find&#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> task(<span class="function"><span class="params">resolver</span>=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(fileName,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">error,data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        resolver.reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">      resolver.resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">&#x27;package.json&#x27;</span>)<span class="comment">//返回task函子</span></span><br><span class="line">  .map(split(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">  .map(find(<span class="function"><span class="params">x</span>=&gt;</span>x.includes(<span class="string">&#x27;version&#x27;</span>)))</span><br><span class="line">  .run()<span class="comment">//执行</span></span><br><span class="line">  .listen(&#123;</span><br><span class="line">    onRejected:<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;,</span><br><span class="line">    onResolved:<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Pointed函子"><a href="#Pointed函子" class="headerlink" title="Pointed函子"></a>Pointed函子</h2><p>pointed函子指实现了of静态方法的函子。</p>
<p>of方法是为了避免使用new来创建对象，更深层上，of方法用来把值放在上下文(context)，然后在上下文中处理值。（把值放在容器中，用map来处理值。）</p>
<h2 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a>Monad函子</h2><p>Monad函子是可以变扁的Pointed函子，解决函子嵌套的问题。</p>
<p>一个函子如果具有join和of两个方法并遵守一些定律，则这个函子为Monad函子。</p>
<p>monad函子内部实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; curry,flowRight&#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line">  map(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(flowRight(fn,<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">  join()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value()</span><br><span class="line">  &#125;</span><br><span class="line">  flatMap(fn)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map(fn).join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(fileName,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">    .flatMap(print)</span><br><span class="line">    .join()</span><br></pre></td></tr></table></figure>

<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>函数式编程<ul>
<li>概念<ul>
<li>是一种编程范式</li>
</ul>
</li>
<li>特性<ul>
<li>1.函数是一等公民</li>
<li>2.变量不可变性</li>
<li>3.无可见的副作用</li>
<li>4.高阶函数</li>
<li>5.闭包</li>
<li>6.柯里化、偏函数</li>
</ul>
</li>
<li>优点<ul>
<li>1.无可见的副作用</li>
<li>2.不易出错，易于测试</li>
<li>3.能够更好的处理并发问题</li>
<li>4.无this指向问题</li>
<li>5.惰性求值，益于性能优化</li>
</ul>
</li>
<li>函数式编程基础<ul>
<li>纯函数</li>
<li>柯里化</li>
<li>管道</li>
<li>函数组合</li>
</ul>
</li>
<li>函子<ul>
<li>Functor</li>
<li>MayBe：处理函数空值问题</li>
<li>Either：处理函数异常问题</li>
<li>IO：处理函数异步问题，返回函子</li>
<li>Monad： 处理函子嵌套调用问题，通过join调用函子</li>
<li>Task：处理函子异步问题</li>
</ul>
</li>
<li>辅助工具<ul>
<li>lodash，lodash/fp</li>
<li>folktale</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<p>备注：<br>函数式编程是一种编程范式。<br>将运算过程抽象成函数<br>常用的编程范式还有：<br>  面向过程编程（命令式编程）、面向对象编程、范型编程等<br>函数式编程中，函数不是指计算机编程中的函数，而是数学中的函数，描述的是输入与输出的映射关系。<br>函数式编程中，变量也非计算机编程中值的存储单元，而是数学中的值，具有不可变性。<br>这也就注定了函数式编程中函数没有副作用的特性，即相同输入会得到相同输出。<br>故而使得函数式编程不易出错，易于测试。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
        </div>

        
        <section class="post-tags">
            <div>
                <span>
                    标签:</span>
                <span class="tag">
                    
                        
                            <a href="/tags/Lodash/">#
                                Lodash</a>
                        
                            <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">#
                                函数式编程</a>
                        
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">后退
                </a>
                <span>·
                </span>
                <a href="/">首页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/10/13/CSS/css3-text-gradient/">CSS3下的渐变文字效果</a>
            
            
                <a class="next" rel="next" href="/2020/10/11/JS/programming-parading/">编程范式</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Qiana | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
